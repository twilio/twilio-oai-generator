/**
 * Twilio - Accounts
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.11.0
 * Contact: support@twilio.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { inspect, InspectOptions } from 'util';
import Page from '../../../../../base/Page';
import V2010 from '../../../V2010';


/**
 * Options to pass to page a RecordingInstance
 *
 * @property { string } [dateCreated] The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. You can also specify inequality: &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60; will return recordings generated at or before midnight on a given date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; returns recordings generated at or after midnight on a date.
 * @property { string } [dateCreated2] The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. You can also specify inequality: &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60; will return recordings generated at or before midnight on a given date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; returns recordings generated at or after midnight on a date.
 * @property { string } [dateCreated3] The &#x60;date_created&#x60; value, specified as &#x60;YYYY-MM-DD&#x60;, of the resources to read. You can also specify inequality: &#x60;DateCreated&lt;&#x3D;YYYY-MM-DD&#x60; will return recordings generated at or before midnight on a given date, and &#x60;DateCreated&gt;&#x3D;YYYY-MM-DD&#x60; returns recordings generated at or after midnight on a date.
 * @property { number } [pageSize] How many resources to return in each list page. The default is 50, and the maximum is 1000.
 */
export interface RecordingListInstancePageOptions {
    dateCreated?: string;
    dateCreated2?: string;
    dateCreated3?: string;
    pageSize?: number;
}

/**
 * Options to pass to update a RecordingInstance
 *
 * @property { string } status The new status of the recording. Can be: &#x60;stopped&#x60;, &#x60;paused&#x60;, &#x60;in-progress&#x60;.
 * @property { string } [pauseBehavior] Whether to record during a pause. Can be: &#x60;skip&#x60; or &#x60;silence&#x60; and the default is &#x60;silence&#x60;. &#x60;skip&#x60; does not record during the pause period, while &#x60;silence&#x60; will replace the actual audio of the call with silence during the pause period. This parameter only applies when setting &#x60;status&#x60; is set to &#x60;paused&#x60;.
 */
export interface RecordingContextUpdateOptions {
    status: string;
    pauseBehavior?: string;
}

export interface RecordingListInstance {
    (accountSid: string, conferenceSid: string, sid: string): RecordingContext;
    get(accountSid: string, conferenceSid: string, sid: string): RecordingContext;


    /**
     * Page a RecordingInstance
     *
     * @param { function } [callback] - Callback to handle processed record
     *
     * @returns { Promise } Resolves to processed RecordingInstance
     */
    page(callback?: (error: Error | null, item?: RecordingInstance) => any): Promise<RecordingInstance>;
    /**
     * Page a RecordingInstance
     *
     * @param { RecordingListInstancePageOptions } params - Parameter for request
     * @param { function } [callback] - Callback to handle processed record
     *
     * @returns { Promise } Resolves to processed RecordingInstance
     */
    page(params: RecordingListInstancePageOptions, callback?: (error: Error | null, item?: RecordingInstance) => any): Promise<RecordingInstance>;
    page(params?: any, callback?: any): Promise<RecordingInstance>
;
    /**
     * Provide a user-friendly representation
     */
    toJSON(): any;
    [inspect.custom](_depth: any, options: InspectOptions): any;
}


interface RecordingListInstanceImpl extends RecordingListInstance {}
class RecordingListInstanceImpl implements RecordingListInstance {
    _version?: V2010;
    _solution?: any;
    _uri?: string;

}

export function RecordingListInstance(version: V2010, accountSid: string, conferenceSid: string): RecordingListInstance {
    const instance = ((accountSid, conferenceSid, sid) => instance.get(accountSid, conferenceSid, sid)) as RecordingListInstanceImpl;

    instance.get = function get(accountSid, conferenceSid, sid): RecordingContext {
        return new RecordingContextImpl(version, accountSid, conferenceSid, sid);
    }

    instance._version = version;
    instance._solution = { accountSid, conferenceSid };
    instance._uri = `/2010-04-01/Accounts/${accountSid}/Conferences/${conferenceSid}/Recordings.json`;

    instance.page = function page(params?: any, callback?: any): Promise<RecordingInstance> {
        if (typeof params === 'function') {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }

        const data: any = {};

        if (params.dateCreated !== undefined) data['DateCreated'] = params.dateCreated;
        if (params.dateCreated2 !== undefined) data['DateCreated<'] = params.dateCreated2;
        if (params.dateCreated3 !== undefined) data['DateCreated>'] = params.dateCreated3;
        if (params.pageSize !== undefined) data['PageSize'] = params.pageSize;

        const headers: any = {};


        let operationVersion = version,
            operationPromise = operationVersion.page({ uri: this._uri, method: 'GET', data, headers });

        operationPromise = operationPromise.then(payload => new RecordingInstance(operationVersion, payload, this._solution.accountSid, this._solution.conferenceSid));

        if (typeof callback === 'function') {
            operationPromise = operationPromise
                .then(value => callback(null, value))
                .catch(error => callback(error));
        }

        return operationPromise;

    }

    instance.toJSON = function toJSON() {
        return this._solution;
    }

    instance[inspect.custom] = function inspectImpl(_depth: any, options: InspectOptions) {
        return inspect(this.toJSON(), options);
    }

    return instance;
}


export interface RecordingContext {


    /**
     * Remove a RecordingInstance
     *
     * @param { function } [callback] - Callback to handle processed record
     *
     * @returns { Promise } Resolves to processed boolean
     */
    remove(callback?: (error: Error | null, item?: RecordingInstance) => any): Promise<boolean>
;
    /**
     * Fetch a RecordingInstance
     *
     * @param { function } [callback] - Callback to handle processed record
     *
     * @returns { Promise } Resolves to processed RecordingInstance
     */
    fetch(callback?: (error: Error | null, item?: RecordingInstance) => any): Promise<RecordingInstance>
;
    /**
     * Update a RecordingInstance
     *
     * @param { RecordingContextUpdateOptions } params - Parameter for request
     * @param { function } [callback] - Callback to handle processed record
     *
     * @returns { Promise } Resolves to processed RecordingInstance
     */
    update(params: RecordingContextUpdateOptions, callback?: (error: Error | null, item?: RecordingInstance) => any): Promise<RecordingInstance>;
    update(params: any, callback?: any): Promise<RecordingInstance>
;
    /**
     * Provide a user-friendly representation
     */
    toJSON(): any;
    [inspect.custom](_depth: any, options: InspectOptions): any;
}

export class RecordingContextImpl implements RecordingContext {
    protected _solution: any;
    protected _uri: string;


    constructor(protected _version: V2010, accountSid: string, conferenceSid: string, sid: string) {
        this._solution = { accountSid, conferenceSid, sid };
        this._uri = `/2010-04-01/Accounts/${accountSid}/Conferences/${conferenceSid}/Recordings/${sid}.json`;
    }

    remove(callback?: any): Promise<boolean> {

        let operationVersion = this._version,
            operationPromise = operationVersion.remove({ uri: this._uri, method: 'DELETE' });


        if (typeof callback === 'function') {
            operationPromise = operationPromise
                .then(value => callback(null, value))
                .catch(error => callback(error));
        }

        return operationPromise;

    }

    fetch(callback?: any): Promise<RecordingInstance> {

        let operationVersion = this._version,
            operationPromise = operationVersion.fetch({ uri: this._uri, method: 'GET' });

        operationPromise = operationPromise.then(payload => new RecordingInstance(operationVersion, payload, this._solution.accountSid, this._solution.conferenceSid, this._solution.sid));

        if (typeof callback === 'function') {
            operationPromise = operationPromise
                .then(value => callback(null, value))
                .catch(error => callback(error));
        }

        return operationPromise;

    }

    update(params: any, callback?: any): Promise<RecordingInstance> {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }

        if (params.status === null || params.status === undefined) {
            throw new Error('Required parameter "params.status" missing.');
        }

        const data: any = {};

        if (params.pauseBehavior !== undefined) data['PauseBehavior'] = params.pauseBehavior;
        data['Status'] = params.status;

        const headers: any = {};
        headers['Content-Type'] = 'application/x-www-form-urlencoded'


        let operationVersion = this._version,
            operationPromise = operationVersion.update({ uri: this._uri, method: 'POST', data, headers });

        operationPromise = operationPromise.then(payload => new RecordingInstance(operationVersion, payload, this._solution.accountSid, this._solution.conferenceSid, this._solution.sid));

        if (typeof callback === 'function') {
            operationPromise = operationPromise
                .then(value => callback(null, value))
                .catch(error => callback(error));
        }

        return operationPromise;

    }

    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */
    toJSON() {
        return this._solution;
    }

    [inspect.custom](_depth: any, options: InspectOptions) {
        return inspect(this.toJSON(), options);
    }
}

export type RecordingSource = 'DialVerb'|'Conference'|'OutboundAPI'|'Trunking'|'RecordVerb'|'StartCallRecordingAPI'|'StartConferenceRecordingAPI';
export type RecordingStatus = 'in-progress'|'paused'|'stopped'|'processing'|'completed'|'absent';

interface RecordingPayload extends RecordingResource, Page.TwilioResponsePayload {
}

interface RecordingResource {
    account_sid?: string | null;
    api_version?: string | null;
    call_sid?: string | null;
    channels?: number | null;
    conference_sid?: string | null;
    date_created?: string | null;
    date_updated?: string | null;
    duration?: string | null;
    encryption_details?: any | null;
    error_code?: number | null;
    price?: string | null;
    price_unit?: string | null;
    sid?: string | null;
    source?: RecordingSource;
    start_time?: string | null;
    status?: RecordingStatus;
    uri?: string | null;
}

export class RecordingInstance {
    protected _solution: any;
    protected _context?: RecordingContext;

    constructor(protected _version: V2010, payload: RecordingPayload, accountSid: string, conferenceSid: string, sid?: string) {
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.callSid = payload.call_sid;
        this.channels = payload.channels;
        this.conferenceSid = payload.conference_sid;
        this.dateCreated = payload.date_created;
        this.dateUpdated = payload.date_updated;
        this.duration = payload.duration;
        this.encryptionDetails = payload.encryption_details;
        this.errorCode = payload.error_code;
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.sid = payload.sid;
        this.source = payload.source;
        this.startTime = payload.start_time;
        this.status = payload.status;
        this.uri = payload.uri;

        this._solution = { accountSid, conferenceSid, sid: sid || this.sid };
    }

    private get _proxy(): RecordingContext {
        this._context = this._context || new RecordingContextImpl(this._version, this._solution.accountSid, this._solution.conferenceSid, this._solution.sid);
        return this._context;
    }

    /**
     * The SID of the Account that created the resource
     */
    accountSid?: string | null;
    /**
     * The API version used to create the recording
     */
    apiVersion?: string | null;
    /**
     * The SID of the Call the resource is associated with
     */
    callSid?: string | null;
    /**
     * The number of channels in the final recording file as an integer
     */
    channels?: number | null;
    /**
     * The Conference SID that identifies the conference associated with the recording
     */
    conferenceSid?: string | null;
    /**
     * The RFC 2822 date and time in GMT that the resource was created
     */
    dateCreated?: string | null;
    /**
     * The RFC 2822 date and time in GMT that the resource was last updated
     */
    dateUpdated?: string | null;
    /**
     * The length of the recording in seconds
     */
    duration?: string | null;
    /**
     * How to decrypt the recording.
     */
    encryptionDetails?: any | null;
    /**
     * More information about why the recording is missing, if status is `absent`.
     */
    errorCode?: number | null;
    /**
     * The one-time cost of creating the recording.
     */
    price?: string | null;
    /**
     * The currency used in the price property.
     */
    priceUnit?: string | null;
    /**
     * The unique string that identifies the resource
     */
    sid?: string | null;
    /**
     * How the recording was created
     */
    source?: RecordingSource;
    /**
     * The start time of the recording, given in RFC 2822 format
     */
    startTime?: string | null;
    /**
     * The status of the recording
     */
    status?: RecordingStatus;
    /**
     * The URI of the resource, relative to `https://api.twilio.com`
     */
    uri?: string | null;

    /**
     * Remove a RecordingInstance
     *
     * @param { function } [callback] - Callback to handle processed record
     *
     * @returns { Promise } Resolves to processed boolean
     */
    remove(callback?: (error: Error | null, item?: RecordingInstance) => any): Promise<boolean>
 {
        return this._proxy.remove(callback);
    }

    /**
     * Fetch a RecordingInstance
     *
     * @param { function } [callback] - Callback to handle processed record
     *
     * @returns { Promise } Resolves to processed RecordingInstance
     */
    fetch(callback?: (error: Error | null, item?: RecordingInstance) => any): Promise<RecordingInstance>
 {
        return this._proxy.fetch(callback);
    }

    /**
     * Update a RecordingInstance
     *
     * @param { RecordingContextUpdateOptions } params - Parameter for request
     * @param { function } [callback] - Callback to handle processed record
     *
     * @returns { Promise } Resolves to processed RecordingInstance
     */
    update(params: RecordingContextUpdateOptions, callback?: (error: Error | null, item?: RecordingInstance) => any): Promise<RecordingInstance>;
    update(params: any, callback?: any): Promise<RecordingInstance>
 {
        return this._proxy.update(params, callback);
    }

    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */
    toJSON() {
        return {
            accountSid: this.accountSid, 
            apiVersion: this.apiVersion, 
            callSid: this.callSid, 
            channels: this.channels, 
            conferenceSid: this.conferenceSid, 
            dateCreated: this.dateCreated, 
            dateUpdated: this.dateUpdated, 
            duration: this.duration, 
            encryptionDetails: this.encryptionDetails, 
            errorCode: this.errorCode, 
            price: this.price, 
            priceUnit: this.priceUnit, 
            sid: this.sid, 
            source: this.source, 
            startTime: this.startTime, 
            status: this.status, 
            uri: this.uri
        }
    }

    [inspect.custom](_depth: any, options: InspectOptions) {
        return inspect(this.toJSON(), options);
    }
}

