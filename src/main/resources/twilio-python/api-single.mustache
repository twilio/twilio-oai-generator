{{>licenseInfo}}
{{#resources}}
from twilio.base import deserialize
from twilio.base import serialize
from twilio.base import values
from twilio.base.instance_context import InstanceContext
from twilio.base.instance_resource import InstanceResource
from twilio.base.list_resource import ListResource
from twilio.base.version import Version
{{#hasPaginationOperation}}
from twilio.base.page import Page
{{/hasPaginationOperation}}
# {{#dependents}}from twilio.rest.{{apiFilename}}.{{filename}} import {{importName}}{{/dependents}}

{{#instancePath}}
class {{apiName}}Context(InstanceContext):
    def __init__(self, version: Version{{#instancePathParams}}, {{paramName}}: {{{dataType}}}{{/instancePathParams}}):
        # TODO: needs autogenerated docs
        super().__init__(version)

        # Path Solution
        self._solution = { {{#instancePathParams}}'{{paramName}}': {{paramName}}, {{/instancePathParams}} }
        self._uri = '{{instancePath}}'
        {{#dependents}}{{#instanceDependent}}
        self._{{mountName}} = None{{/instanceDependent}}{{/dependents}}
    {{#operations}}{{#vendorExtensions.x-is-context-operation}}
    def {{vendorExtensions.x-name-lower}}(self{{#allParams}}, {{paramName}}{{/allParams}}):
        {{#vendorExtensions.x-is-update-operation}}data = values.of({
            {{#allParams}}'{{paramName}}': {{paramName}},{{/allParams}}
        })

        payload = self._version.update(method='{{httpMethod}}', uri=self._uri, data=data, )

        return {{apiName}}Instance(self._version, payload, {{#instancePathParams}}{{paramName}}=self._solution['{{paramName}}'], {{/instancePathParams}})
        {{/vendorExtensions.x-is-update-operation}}
        {{#vendorExtensions.x-is-fetch-operation}}"""
        Fetch the {{apiName}}Instance

        :returns: The fetched {{apiName}}Instance
        #TODO: add rtype docs
        """
        payload = self._version.fetch(method='GET', uri=self._uri, )

        return {{apiName}}Instance(self._version, payload, {{#instancePathParams}}{{paramName}}=self._solution['{{paramName}}'], {{/instancePathParams}})
        {{/vendorExtensions.x-is-fetch-operation}}

        {{#vendorExtensions.x-is-delete-operation}}"""
        Deletes the {{apiName}}Instance

        :returns: True if delete succeeds, False otherwise
        :rtype: bool
        """
        return self._version.delete(method='DELETE', uri=self._uri, ){{/vendorExtensions.x-is-delete-operation}}
    {{/vendorExtensions.x-is-context-operation}}{{/operations}}

    def __repr__(self):
        """
        Provide a friendly representation
        :returns: Machine friendly representation
        :rtype: str
        """
        return '<Twilio.Api.{{apiVersionClass}}.{{apiName}}Context>'

{{/instancePath}}
{{#responseModel}}
class {{apiName}}Instance(InstanceResource):
    def __init__(self, version, payload{{#instancePathParams}}, {{paramName}}: {{{dataType}}}{{/instancePathParams}}):
        super().__init__(version)
        self._properties = { {{#vars}}
            '{{name}}' : payload.get('{{{baseName}}}'),{{/vars}}
        }

        self._context = None
        self._solution = {
            {{#instancePathParams}}'{{paramName}}': {{paramName}} or self._properties['{{paramName}}'],{{/instancePathParams}}
        }

    @property
    def _proxy(self):
        if self._context is None:
            self._context = {{apiName}}Context(
                self._version,
                {{#instancePathParams}}{{paramName}}=self._solution['{{paramName}}'],{{/instancePathParams}}
            )
        return self._context

    {{#dependents}}{{#instanceDependent}}@property
    def {{mountName}}(self):
        return self._proxy.{{mountName}}
    {{/instanceDependent}}{{/dependents}}

    def __repr__(self):
        """
        Provide a friendly representation
        :returns: Machine friendly representation
        :rtype: str
        """
        context = ' '.join('{}={}'.format(k, v) for k, v in self._solution.items())
        return '<Twilio.Api.{{apiVersionClass}}.{{apiName}}Instance {}>'.format(context)

{{/responseModel}}

class {{apiName}}List(ListResource):
    def __init__(self, version: Version{{#listPathParams}}, {{paramName}}: {{{dataType}}}{{/listPathParams}}):
        # TODO: needs autogenerated docs
        super().__init__(version)

        # Path Solution
        self._solution = { {{#listPathParams}}'{{paramName}}': {{paramName}}, {{/listPathParams}} }
        self._uri = '{{listPath}}'
        {{#dependents}}{{^instanceDependent}}
        self._{{mountName}} = None{{/instanceDependent}}{{/dependents}}
    {{#operations}}{{#vendorExtensions.x-is-list-operation}}

    def {{vendorExtensions.x-name-lower}}(self{{#allParams}}, {{paramName}}{{/allParams}}):
        {{#vendorExtensions.x-is-create-operation}}data = values.of({
            {{#allParams}}'{{paramName}}': {{paramName}}, {{/allParams}}
        })

        payload = self._version.create(method='{{httpMethod}}', uri=self._uri, data=data, )

        return {{apiName}}Instance(self._version, payload, {{#listPathParams}}{{paramName}}=self._solution['{{paramName}}']{{/listPathParams}}){{/vendorExtensions.x-is-create-operation}}
        {{#vendorExtensions.x-is-read-operation}}data = values.of({
            {{#allParams}}'{{paramName}}': {{paramName}}, {{/allParams}}
        })

        response = self._version.page(method='{{httpMethod}}', uri=self._uri, data=data, )

        return {{apiName}}Page(self._version, response, self.solution)

    def stream(self{{#allParams}}, {{paramName}}=values.unset{{/allParams}}, limit=None, pageSize=None):
        limits = self._version.read_limits(limit, page_size)

        page = self.page({{#allParams}}{{paramName}}=values.unset, {{/allParams}}limit=None, page_size=None)

        return self._version.stream(page, limits['limit'])


    def list(self{{#allParams}}, {{paramName}}=values.unset{{/allParams}}, limit=None, pageSize=None):
        return list(self.stream(
            {{#allParams}}{{paramName}}={{paramName}},
            {{/allParams}}
            limit=limit,
            page_size=page_size
        ))

    def get_page(self, target_url):
        response = self._version.domain.twilio.request(
            'GET',
            target_url,
        )

        return {{apiName}}Page(self._version, response, self._solution)
    {{/vendorExtensions.x-is-read-operation}}
    {{/vendorExtensions.x-is-list-operation}}{{/operations}}

    {{#hasPaginationOperation}}

    {{/hasPaginationOperation}}

    # @properties

    def get(self, {{#instancePathParams}}{{paramName}}{{/instancePathParams}}):
        return {{apiName}}Context(self._version,  {{#instancePathParams}}{{paramName}}, {{/instancePathParams}})


    def __repr__(self):
        """
        Provide a friendly representation
        :returns: Machine friendly representation
        :rtype: str
        """
        return '<Twilio.Api.{{apiVersionClass}}.{{apiName}}ListInstance>'

{{#hasPaginationOperation}}
{{#responseModel}}
class {{apiName}}Page(Page):

    def __init__(self, version, response, solution):
        super().__init__(version, response)

        # Path solution
        self._solution = solution

    def get_instance(self, payload):
        return {{apiName}}Instance(self._version, payload{{#instancePathParams}}, {{paramName}}=self._solution['{{paramName}}']{{/instancePathParams}})

    def __repr__(self):
        return '<Twilio.{{apiName}}.{{apiVersionClass}}.{{apiName}}Page'
{{/responseModel}}

{{/hasPaginationOperation}}
{{/resources}}
